#!/usr/bin/perl
 
use strict;
use warnings;
use English;
use OpenXPKI::Debug;
use OpenXPKI::Control;
use Getopt::Long;
use Pod::Usage;
use POSIX ":sys_wait_h";
use Errno;
use File::Spec;
use Proc::ProcessTable;

use OpenXPKI::Server::Init;
use OpenXPKI::Server::Context qw( CTX );

use OpenXPKI::VERSION;

use Data::Dumper;


my %params;
my @options_spec = ('config=s');
my $cmd = shift || 'help';
my $ret = 255;
 
sub initdb {

    my @databases = qw( backend );
    
    # Check if a seperate logging database is defined
         
    if (CTX('config')->get('system.database.logging.type')) {
        push @databases, 'log';
    }     
    
  DB:
    foreach my $db (@databases) {
        my $params = {};
        $params->{PURPOSE} = $db;

        if ( defined $params->{PURPOSE} ) {
            print STDERR "Setting up database '$db'\n";
        }
        my $dbi = OpenXPKI::Server::Init::get_dbi($params);

        eval { $dbi->connect() };
        if ($EVAL_ERROR) {
            print STDERR
              "ERROR: Could not connect to '$db' database ($EVAL_ERROR)\n";
            return 2;
        }

        if ( $params{'dry-run'} ) {
            print $dbi->init_schema( MODE => 'DRYRUN' ) . "\n";
            last DB;
        }
        else {
            my %args = ();
            if ( $params{force} ) {
                $args{MODE} = 'FORCE';
            }

            #### args for init_schema : Dumper(\%args)
            eval { $dbi->init_schema(%args); };
            if ($EVAL_ERROR) {
                print STDERR
                  "ERROR: init_schema on '$db' failed (${EVAL_ERROR})\n";
                return 2;
            }
            print STDERR "Database '$db' initialized.\n";
        }
    }
    return 0;
} 


sub loadcfg {
    
    if ($params{path}) {
        # we set the ENV as this
        # a) can split a string
        # b) otherwise an external set ENV will override the parameter
        $ENV{OPENXPKI_CONF_PATH} = $params{path};
    }   
    
    require OpenXPKI::Config::Merge;
    my $config = OpenXPKI::Config::Merge->new();    
    printf "Current Tree Version: %s\n", $config->version();
    
    if ($params{reload}) {
        OpenXPKI::Control::reload(); 
    }      
    return;
    
}
 
sub certificate_import {

    print STDERR "Strating import\n";
    
    my $defaulttoken = CTX('crypto_layer')->get_system_token({TYPE => 'DEFAULT'});

    if ( !defined $defaulttoken ) {
        print STDERR "ERROR: Could not get default token\n";
        return 2;
    }
    
    my $dbi = __get_dbi();
  
    my $filename = $params{file};

    if ( !-r $filename ) {
        print STDERR "ERROR: filename '$filename' is not readable\n";
        return 2;
    }

    my $FileUtils = OpenXPKI::FileUtils->new();
    my $certdata  = $FileUtils->read_file($filename);

    if ( !defined $certdata ) {
        print STDERR "ERROR: Could not parse certificate data\n";
        return 2;
    }

    if (   ( !defined $params{issuer} || $params{issuer} eq '' )
        && ( defined $params{realm} ) )
    {
        print STDERR "ERROR: You have to specify an issuer (or leave "
          . "out --realm for self-signed certificates).\n";
        return 1;
    }

    my ($extracted_certdata) = $certdata =~ m{ \A .* (-----BEGIN\ CERTIFICATE----- .* -----END\ CERTIFICATE-----) .* \z}xms;

    my $cert = OpenXPKI::Crypto::X509->new(
        TOKEN => $defaulttoken,
        DATA  => $extracted_certdata,
    );
    #### cert : Dumper($cert)

    my $realm;
    my $issuer_identifier;
    if ( !defined $params{realm} || $params{realm} eq '' ) {

        # user wants to import a self-signed
        # cert, let's check if it really is one
        ### subject key id : $cert->get_subject_key_id()
        ### authority key id : $cert->get_authority_key_id()
        if (
               defined $cert->get_subject_key_id()
            && defined $cert->get_authority_key_id()
            && ref $cert->get_authority_key_id() eq '' # TODO: check if hash
            && (
                $cert->get_subject_key_id() ne $cert->get_authority_key_id()
            )
          )
        {
            if ( !defined $params{'force-really-self-signed'} ) {
                print STDERR "ERROR: This is not a self-signed "
                  . "certificate, "
                  . "(subject key id and authority key id do not match) "
                  . "please specify --realm if you want to import a "
                  . "normal certificate.\n";
                exit 1;
            }
        }
        if ( $cert->{PARSED}->{BODY}->{SUBJECT} ne
            $cert->{PARSED}->{BODY}->{ISSUER} )
        {
            if ( !defined $params{'force-really-self-signed'} ) {
                print STDERR "ERROR: This is not a self-signed "
                  . "certificate, "
                  . "(subject and issuer do not match) "
                  . "please specify --realm if you want to import a "
                  . "normal certificate.\n";
                return 2;
            }
        }

        # we are our own issuer
        $issuer_identifier = $cert->get_identifier();
    }
    else {    # we have a "normal" certificate
        if ( defined $params{'issuer-realm'} ) {
            $realm = $params{'issuer-realm'};
        }
        else {
            $realm = $params{realm};
        }

        # maybe the issuer name is an alias, try to resolve it
        $issuer_identifier = __resolve_alias(
            {
                DBI   => $dbi,
                NAME  => $params{issuer},
                REALM => $realm,
            }
        );
        ### issuer_identifier : $issuer_identifier
        # check whether the certificate is in the DB
        my $issuer = $dbi->first(
            TABLE   => 'CERTIFICATE',
            DYNAMIC => { IDENTIFIER => $issuer_identifier, },
        );
        if (   !defined $issuer
            && !defined $params{'force-issuer-not-found'} )
        {
            print STDERR "ERROR: Issuer '$params{issuer}' not found in "
              . "the database.\n";
            return 2;
        }
    }

    # make sure the self-signed realm is specified as 'undef'
    if ( defined $realm && ( $realm eq '' ) ) {
        $realm = undef;
    }

    # compile all relevant data for the database
    # TODO: use $cert->to_db_hash();
    my %insert_hash;
    $insert_hash{STATUS}             = 'ISSUED';
    $insert_hash{PKI_REALM}          = $realm;
    $insert_hash{CERTIFICATE_SERIAL} = $cert->get_serial();
    $insert_hash{IDENTIFIER}         = $cert->get_identifier();
    $insert_hash{DATA}               = $extracted_certdata;
    $insert_hash{SUBJECT}            = $cert->{PARSED}->{BODY}->{SUBJECT};
    $insert_hash{ISSUER_DN}          = $cert->{PARSED}->{BODY}->{ISSUER};
    $insert_hash{ISSUER_IDENTIFIER}  = $issuer_identifier;

    # combine email addresses
    if ( exists $cert->{PARSED}->{BODY}->{EMAILADDRESSES} ) {
        $insert_hash{EMAIL} = '';
        foreach my $email ( @{ $cert->{PARSED}->{BODY}->{EMAILADDRESSES} } )
        {
            $insert_hash{EMAIL} .= "," if ( $insert_hash{EMAIL} ne '' );
            $insert_hash{EMAIL} .= $email;
        }
    }
    $insert_hash{PUBKEY} = $cert->{PARSED}->{BODY}->{PUBKEY};

    # set subject key id and authority key id, if defined.
    if ( defined $cert->get_subject_key_id() ) {
        $insert_hash{SUBJECT_KEY_IDENTIFIER} = $cert->get_subject_key_id();
    }
    if ( defined $cert->get_authority_key_id()
        && ref $cert->get_authority_key_id() eq '' )
    {

        # TODO: do we save if authority key id is hash, and if
        # yes, in which format?
        $insert_hash{AUTHORITY_KEY_IDENTIFIER} =
          $cert->get_authority_key_id();
    } 

    $insert_hash{NOTAFTER} = OpenXPKI::DateTime::convert_date(
        {
            DATE      => $cert->{PARSED}->{BODY}->{NOTAFTER},
            OUTFORMAT => 'epoch',
        }
    );
    $insert_hash{NOTBEFORE} = OpenXPKI::DateTime::convert_date(
        {
            DATE      => $cert->{PARSED}->{BODY}->{NOTBEFORE},
            OUTFORMAT => 'epoch',
        }
    );

    # fields which are explicitly NOT set:
    # LOA          (we don't know it)
    # CSR_SERIAL   ( " " )

    # check whether there is already a certificate with the given
    # identifier anywhere
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $insert_hash{IDENTIFIER}, },
    );
    if ( defined $certificate
        && !defined $params{'force-certificate-already-exists'} )
    {
        if ( $certificate->{PKI_REALM} ne '' ) {
            print STDERR "ERROR: The same certificate already exists "
              . "in the $certificate->{PKI_REALM} realm. Use openxpkiadm "
              . "certificate alias to reference it.\n";
        }
        else {
            print STDERR "ERROR: The same certificate already exists  "
              . "as a global self-signed certificate. Use openxpkiadm "
              . "certificate alias to reference it.\n";
        }
        return 2;
    }
    $dbi->insert(
        TABLE => 'CERTIFICATE',    # use hash method
        HASH  => \%insert_hash,
    );
    $dbi->commit();

    print "Successfully imported certificate into database:\n";
    print "  Subject:    " . $insert_hash{SUBJECT} . "\n";
    print "  Issuer:     " . $insert_hash{ISSUER_DN} . "\n";
    print "  Identifier: " . $insert_hash{IDENTIFIER} . "\n";
    return 0;
    
}


sub certificate_remove {
    
    my $name  = $params{name};
    my $realm = $params{realm};

    my $identifier = $name;
    
    my $dbi = __get_dbi();
    
    if ( defined $realm ) {
        $identifier = __resolve_alias(
            {
                DBI   => $dbi,
                NAME  => $name,
                REALM => $realm,
            }
        );
    }

    # check if certificate is issuer of something
    my $children_dbi = $dbi->select(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { ISSUER_IDENTIFIER => $identifier, },
    );
    my @children = @{$children_dbi};

    my $is_issuer = 0;
    if ( scalar @children > 0 ) {
        $is_issuer = 1;
        if ( scalar @children == 1 ) {
            if ( $children[0]->{'ISSUER_IDENTIFIER'} eq $identifier ) {

                # only self-signed certificate, delete even though
                # it formally is the issuer of a certificate in the DB
                $is_issuer = 0;
            }
        }
    }

    if ( $is_issuer && !defined $params{'force-is-issuer'} ) {
        print STDERR "ERROR: Certificate not deleted because it is referenced as the issuer of "
          . scalar @children
          . " certificate(s) in the database.\n";
        return 2;
    }
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $identifier, },
    );
    if ( defined $certificate ) {
        $dbi->delete(
            TABLE => 'CERTIFICATE',
            DATA  => { IDENTIFIER => $identifier, },
        );
        $dbi->commit();
        print "Successfully deleted certificate $name "
          . "(identifier: $identifier) from database.\n";
        return 0;
    }
    else {
        print STDERR "ERROR: Certificate $name "
          . "(identifier: $identifier) not found in database.\n";
        return 2;
    }
}

sub alias_add {
    
    my %insert_hash = ();

    my $dbi = __get_dbi();
    
    $insert_hash{PKI_REALM} = $params{realm};

    # Import of named tokens always ba group and generation
    if ( $params{token} ) {
        my $group = CTX('config')->get("realm.$params{realm}.crypto.type.$params{token}");
        
        if (!$group) {
            print STDERR "There is no token of type $params{token} defined\n";
            return 2;
        }
        # query aliases to get next generation id
        my $next_generation = $dbi->first(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                PKI_REALM => $params{realm},
                GROUP_ID => $group, 
            },
            'ORDER' => [ 'GENERATION' ],
            'REVERSE' => 1,                       
        );        
        $insert_hash{GENERATION} = $next_generation->{GENERATION} + 1; 
        $insert_hash{GROUP_ID} = $group;
        $insert_hash{ALIAS} = sprintf "%s-%01d", $group, $insert_hash{GENERATION};   
             
    } elsif ( $params{group} && $params{gen} ) {
                
        $insert_hash{GENERATION} = $params{gen}; 
        $insert_hash{GROUP_ID} = $params{group};
        $insert_hash{ALIAS} = sprintf "%s-%01d", $params{group}, $params{gen};
        
    } elsif ( !exists( $params{alias} ) || $params{alias} eq '' ) {
        print STDERR "Please specify an alias with --alias\n";
        return 1;
        
    } else {
        
        $insert_hash{ALIAS} = $params{alias};
    }
    
    if ( !exists( $params{identifier} ) || $params{identifier} eq '' ) {
        print STDERR "Please specify an identifier with --identifier\n";
        return 1;
    } else {
        $insert_hash{IDENTIFIER} = $params{identifier};
    }


    # query certificate table to check whether --identifer actually exists
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $insert_hash{IDENTIFIER}, },
    );

    if ( !defined $certificate && !defined $params{'force-certificate-not-found'} ) {   
        # there is no cert with given identifier
        print STDERR "ERROR: Could not find a certificate with "
          . "identifier '$insert_hash{IDENTIFIER}', "
          . "are you sure it is correct?\n"
          . "Add --force-certificate-not-found to force insert.";
        return 2;
    }
    
    #### insert_hash : Dumper(\%insert_hash)
    $dbi->insert(
        TABLE => 'ALIASES',
        HASH  => \%insert_hash,
    );
    $dbi->commit();
    print "Successfully created alias in realm $params{realm}:\n";
    print "  Alias     : $insert_hash{ALIAS}\n";
    print "  Identifier: $insert_hash{IDENTIFIER}\n";
    return 0;
    
}    

sub certificate_chain {
    
    my $cert_name;
    my $issuer_name;
    if ( !exists( $params{name} ) || $params{name} eq '' ) {
        print STDERR "Please specify a certificate name with --name\n";
        return 1;
    }
    else {
        $cert_name = $params{name};
    }
    if ( !exists( $params{issuer} ) || $params{issuer} eq '' ) {
        print STDERR "Please specify an issuer name with --issuer\n";
        return 1;
    }
    else {
        $issuer_name = $params{issuer};
    }

    my $dbi = __get_dbi();

    # maybe the certificate name is an alias, try to resolve it
    my $cert_identifier = __resolve_alias(
        {
            DBI   => $dbi,
            NAME  => $cert_name,
            REALM => $params{realm},
        }
    );

    # check whether the certificate is in the DB
    my $certificate = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => {
            IDENTIFIER => $cert_identifier,
            PKI_REALM  => $params{realm}
        },
    );
    if (   !defined $certificate
        && !defined $params{'force-certificate-not-found'} )
    {
        print STDERR "ERROR: Certificate '$cert_name' not found in realm "
          . "$params{realm}.\n";
        return 2;
    }

    my $issuer_identifier;

    # maybe the issuer name is an alias, try resolve it
    my $realm;
    if ( defined $params{'issuer-realm'} ) {
        $realm = $params{'issuer-realm'};
    }
    else {
        $realm = $params{realm};
    }
    $issuer_identifier = __resolve_alias(
        {
            DBI   => $dbi,
            NAME  => $issuer_name,
            REALM => $realm,
        }
    );

    # check whether the issuer is in the DB
    my $issuer = $dbi->first(
        TABLE   => 'CERTIFICATE',
        DYNAMIC => { IDENTIFIER => $issuer_identifier, },
    );
    if (   !defined $issuer
        && !defined $params{'force-issuer-certificate-not-found'} )
    {
        print STDERR "ERROR: Issuer certificate '$issuer_name' "
          . "(identifier: $issuer_identifier) not found in database.\n";
        return 2;
    }

    # set the issuer_identifier for the given certificate
    $dbi->update(
        TABLE => 'CERTIFICATE',
        DATA  => { ISSUER_IDENTIFIER => $issuer_identifier, },
        WHERE => {
            CERTIFICATE_SERIAL => $certificate->{CERTIFICATE_SERIAL},
            IDENTIFIER         => $cert_identifier,
            PKI_REALM          => $certificate->{PKI_REALM},
        },
    );
    $dbi->commit();
    print "Successfully set $issuer_name (identifier: $issuer_identifier) "
      . "as issuer of certificate $cert_name (identifier: "
      . "$cert_identifier).\n";

    # TODO: maybe don't warn only, but let the user use --force to
    # specify that he knows what he is doing ...?
    if ( $issuer->{SUBJECT_KEY_IDENTIFIER} ne
        $certificate->{AUTHORITY_KEY_IDENTIFIER} )
    {
        print STDERR "WARNING: The issuer's subject key identifier "
          . "extension ($issuer->{SUBJECT_KEY_IDENTIFIER}) does not "
          . "match the authority key identifier extension contained "
          . "in the certificate "
          . "($certificate->{AUTHORITY_KEY_IDENTIFIER}). Are you sure "
          . "your chain is correct?\n";
    }
    if ( $issuer->{SUBJECT} ne $certificate->{ISSUER_DN} ) {
        print STDERR "WARNING: The issuer's subject ($issuer->{SUBJECT}) "
          . "does not match the issuer DN contained in the certificate "
          . "($certificate->{ISSUER_DN}). Are you sure your chain is "
          . "correct?\n";
    }
    return 0;
        
}

sub certificate_list {
    
    my @realms;
    if ( defined $params{realm} ) {
        push @realms, $params{realm};
    }
    else {
        @realms = CTX('config')->get_keys('system.realms');
        push @realms, undef;    # add the magic empty realm
    }

    my $dbi = __get_dbi();
    foreach my $realm (@realms) {
        if ( defined $realm ) {
            print "\nCertificates in $realm:\n";
        }
        else {
            print "\nCertificates in self-signed pseudo-realm:\n";
        }
        my $certificates;
        if ( defined $params{all} ) {
            $certificates = $dbi->select(
                TABLE   => 'CERTIFICATE',
                DYNAMIC => { PKI_REALM => $realm, },
            );
        }
        else {
            $certificates = $dbi->select(
                TABLE   => [ 'ALIASES', 'CERTIFICATE' ],
                COLUMNS => [
                    'ALIASES.ALIAS',
                    'ALIASES.IDENTIFIER',
                    'CERTIFICATE.SUBJECT',
                    'CERTIFICATE.ISSUER_DN',
                    'CERTIFICATE.CERTIFICATE_SERIAL',
                    'CERTIFICATE.ISSUER_IDENTIFIER',
                    'CERTIFICATE.DATA',
                    'CERTIFICATE.EMAIL',
                    'CERTIFICATE.STATUS',
                    'CERTIFICATE.ROLE',
                    'CERTIFICATE.PUBKEY',
                    'CERTIFICATE.SUBJECT_KEY_IDENTIFIER',
                    'CERTIFICATE.AUTHORITY_KEY_IDENTIFIER',
                    'CERTIFICATE.NOTAFTER',
                    'CERTIFICATE.LOA',
                    'CERTIFICATE.NOTBEFORE',
                    'CERTIFICATE.CSR_SERIAL',
                ],
                JOIN => [ [ 'IDENTIFIER', 'IDENTIFIER', ], ],
                DYNAMIC => { 'ALIASES.PKI_REALM' => $realm, },
            );
        }
        for ( my $i = 0 ; $i < scalar @{$certificates} ; $i++ ) {
            my $cert = $certificates->[$i];
            my $identifier;
            if ( defined $params{all} ) {    # look up aliases
                $identifier = $cert->{IDENTIFIER};
                my $status = $cert->{STATUS};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{IDENTIFIER}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: " . $cert->{IDENTIFIER} . "\n";
                }
                my $aliases = $dbi->select(
                    TABLE   => 'ALIASES',
                    DYNAMIC => { IDENTIFIER => $cert->{IDENTIFIER}, },
                );
                for ( my $j = 0 ; $j < scalar @{$aliases} ; $j++ ) {
                    print "    Alias:\n      "
                      . $aliases->[$j]->{ALIAS}
                      . " (in realm: "
                      . $aliases->[$j]->{PKI_REALM} . ")\n";
                }
            }
            else {
                $identifier = $cert->{'ALIASES.IDENTIFIER'};
                my $status = $cert->{'CERTIFICATE.STATUS'};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{'ALIASES.IDENTIFIER'}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: "
                      . $cert->{'ALIASES.IDENTIFIER'} . "\n";
                }
                print "    Alias:\n       "
                  . $cert->{'ALIASES.ALIAS'} . "\n";
            }
            my $prefix = '';
            if ( !defined $params{all} ) {
                $prefix = 'CERTIFICATE.';
            }
            if ( defined $params{v} && $params{v} > 0 ) {

                # show subject and issuer dn
                my $subject   = $cert->{ $prefix . 'SUBJECT' };
                my $issuer_dn = $cert->{ $prefix . 'ISSUER_DN' };
                print "    Subject:\n      " . $subject . "\n";
                print "    Issuer DN:\n      " . $issuer_dn . "\n";
            }
            if ( defined $params{v} && $params{v} > 1 ) {

                # show chain
                my $api = CTX('api');
                my $chain =
                  $api->get_chain( { START_IDENTIFIER => $identifier, } );
                my $chain_str = join( ' -> ', @{ $chain->{IDENTIFIERS} } );

                print "    Chain: $chain_str ";
                if ( $chain->{COMPLETE} == 1 ) {
                    print "(complete)\n";
                }
                else {
                    print "(INcomplete!)\n";
                }
            }
            if ( defined $params{v} && $params{v} > 2 ) {

                # show database entry
                my @fields = qw(
                  SUBJECT_KEY_IDENTIFIER
                  AUTHORITY_KEY_IDENTIFIER
                  CERTIFICATE_SERIAL
                  ISSUER_IDENTIFIER
                  EMAIL
                  STATUS
                  ROLE
                  NOTAFTER
                  NOTBEFORE
                  CSR_SERIAL
                  LOA
                );

                if ( $params{v} > 3 ) {
                    push @fields, qw(PUBKEY DATA);
                }

                foreach my $field (@fields) {
                    my $value;
                    if ( defined $cert->{ $prefix . $field } ) {
                        $value = $cert->{ $prefix . $field };
                    }
                    else {
                        $value = 'NULL';
                    }
                    print "    $field:\n      " . $value . "\n";
                }
            }
        }
    }
    exit 0;
}

sub alias_del {
    
    my %delete_hash = ();

    $delete_hash{PKI_REALM} = $params{realm};
    
    if ($params{identifier}) {
        $delete_hash{IDENTIFIER} = $params{identifier};    
    } elsif ($params{alias}) {
        $delete_hash{ALIAS} = $params{alias};
    } else {
        print STDERR "You must specify either --identifier or --alias\n";
        return 1;
    }
    
    my $dbi = __get_dbi();
    
    my $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => \%delete_hash,
    );

    if (!$alias) {
        print STDERR "No alias entry found matching your request\n";
        return 2;
    }

    $dbi->delete(TABLE => 'ALIASES', DATA => $alias);
    $dbi->commit();
    print "Successfully removed the alias $alias->{ALIAS}:\n";    
    print "   Identifier: $alias->{IDENTIFIER}\n";    
    print "   Realm:      $alias->{PKI_REALM}\n";
    
    return 0;
    
}    

sub key_list {
    
    my $dbi = __get_dbi();
    my $config = CTX('config');
    my $realm = $params{realm};
    
    # TODO - Improve!
    # We use the alias table to find all keys in the realm
    # For the moment we assume the keys are defined explicit in the config
    # this will change in the future when we allow autodiscovery and default inheritance
    my $token_class = $config->get_hash("realm.$realm.crypto.type");

    foreach my $class (keys %{$token_class}) {
        my $db_alias = $dbi->select(
            TABLE   => 'ALIASES',
            DYNAMIC => {
                GROUP_ID     => $token_class->{$class},
                PKI_REALM => $realm,
            },
        );

        print "Keys for token group $token_class->{$class}\n";
        foreach my $entry (@{ $db_alias }) {
            my $alias = $entry->{ALIAS};
            my $key = $config->get("realm.$realm.crypto.token.$alias.key");
            
            my $status_flag = '?';
            if (!$key) {
                $status_flag = 'c';    
            }elsif ( -e $key && ( !-s $key ) ) {
                $status_flag = '0';    # file exists but is of size zero
            }   elsif ( -e $key ) {        # file exists and is non-zero
                $status_flag = '+';
            } else {                     # file does not exist (yet)
                $status_flag = '!';
            }
            print '    ' . $status_flag . ' ' . $alias . "\n";                        
        }
    }

    return 0;
}

sub __get_dbi {
    
    my $dbi = CTX('dbi_backend');
    if ( !defined $dbi ) {
        die "ERROR: Could not instantiate database backend\n";        
    }
    $dbi->connect();
    return $dbi;
}

sub __resolve_alias {
 
    my $arg_ref = shift;
    my $dbi     = $arg_ref->{DBI};
    my $name    = $arg_ref->{NAME};
    my $realm   = $arg_ref->{REALM};

    my $alias = $dbi->first(
        TABLE   => 'ALIASES',
        DYNAMIC => {
            ALIAS     => $name,
            PKI_REALM => $realm,
        },
    );
    if ( defined $alias ) {
        return $alias->{IDENTIFIER};
    }
    else {
        return $name;
    }
}

sub __init {
    
    GetOptions( \%params, @options_spec ) or pod2usage( -verbose => 0 );
        
    if ($params{config}) {
        # we set the ENV here to outrule an external ENV setting and to have 
        # it ready for the reload action (needed to find the correct pidfile)
        $ENV{OPENXPKI_CONF_DB} = $params{config};
    }
        
}
 
if ($cmd eq 'initdb') {

    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned'], SILENT => 1,});

    push @options_spec, qw(dry-run force);
    __init();
    $ret = initdb();       
    
} elsif ($cmd eq 'loadcfg') {

    push @options_spec, qw(
        path=s 
        config|dbpath=s 
        reload
    );    
    __init();
    $ret = loadcfg();    

} elsif ($cmd eq 'certificate') {

    my $subcmd = shift;
    
    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','dbi_log','log','api','crypto_layer','dbi_backend'], SILENT => 1,});
    
    if ($subcmd eq 'import') {
    
        push @options_spec, qw(
            realm=s
            file=s
            issuer=s
            issuer-realm=s
            role=s
            force-really-self-signed
            force-issuer-not-found
            force-certificate-already-exists
            );
        
        __init();
        if (!$params{file}) {
            die "You need to specify the certificate to import with --file\n";    
        }
        
        if (!$params{issuer} && defined $params{realm}) {
            die "You must specify --issuer and --realm or leave both empty\n";
        }
        
        if ((!$params{alias} && $params{group}) || ($params{alias} && !$params{group})) {
            die "You must always specify both --alias and --group \n";
        }
                  
        $ret = certificate_import();
        
    } elsif ($subcmd eq 'remove') {
        
        push @options_spec, qw(
            realm=s
            name=s
            force-is-issuer
        );
        __init();
        $ret = certificate_remove();
        
    } elsif ($subcmd eq 'chain') {
        
        push @options_spec, qw(
            issuer=s
            issuer-realm=s
            name=s
            force-certificate-not-found
            force-issuer-certificate-not-found
        );
        __init();        
        $ret = certificate_chain();     
           
    } elsif ($subcmd eq 'list') {
        
        push @options_spec, qw(
            realm=s
            all
            v+
        );
        __init();        
        $ret = certificate_list();        
    }


} elsif ($cmd eq 'alias') {
           
    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','dbi_log','log','api','dbi_backend'], SILENT => 1,});
           
    push @options_spec, qw(
      alias=s
      remove
      realm=s
      gen|generation=s
      group=s
      token=s
      identifier=s
      force-certificate-not-found
    );
    __init();
        
    if (!$params{realm}) {
        die "You must specify a realm using --realm\n";
    }
        
    if ($params{remove}) {
        $ret = alias_del();
    } else {    
        $ret = alias_add();
    }
} elsif ($cmd eq 'key') {
    
    my $subcmd = shift;
    
    if ($subcmd eq 'list') {
        
        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','api','dbi_backend'], SILENT => 1,});
               
        push @options_spec, qw(
          realm=s          
        );
        __init();
            
        if (!$params{realm}) {
            die "You must specify a realm using --realm\n";            
        }

        $ret = key_list();
            
    }
}

if ($ret) {
    pod2usage( -verbose => 0 );
    exit $ret;
}

exit 0;

1;


__END__

=head1 NAME

openxpkiadm - tool for management operations of OpenXPKI instances

=head1 USAGE

openxpkiadm COMMAND [SUBCOMMAND] [OPTIONS]

 Global options:
   --config DIR          Location of the configuration repository
                         optional, defaults to /etc/openxpki/config.git   

 Commands:
   help                  brief help message
   man                   full documentation
   version               print program version and exit   
   initdb                Initialize database
   key                   Manage keys
   certificate           Manage certificates
   loadcfg               Import updated config from the filesystem      

=head1 ARGUMENTS

Available commands:

=head2 initdb

Command options:

   --force               Force operation (may be destructive)
   --dryrun              Don't change anything, just print what would
                         be done

Initializes the OpenXPKI database schema. Will not destroy existing data
unless called with --force.

=head2 key

Key management for OpenXPKI Tokens (including issuing CAs and subsystems).

Command options:

   --realm               PKI Realm to operate on

=head3 key management subcommands

=over 8

=item B<list>

Shows token key information for the specified realm, including 
key algorithm, key length and secret splitting information.
TODO: Key info not implemented yet!

Lists keys together with a status flag, which can be one of the
following:

  c - token not defined in crypto.token
  + - key exists and file is non-empty
  0 - key exists but file is empty
  ! - key files does not exist (yet)
  

Example:

  openxpkiadm key list --realm 'Root CA' 
 
=back

=head2 certificate

Starts a certificate management command and allows to list, install,
delete and connect certificates for the configured PKI Realms.

  openxpkiadm certificate <subcommand> <options>

=head3 certificate management subcommands

=over 8

=item B<list>

Subcommand options (optional):

   --realm                  PKI realm to operate on
   --all                    Show all certificates
   -v                       Show subject and issuer DN as well
   -v -v                    Show chain as well
   -v -v -v                 Show (nearly complete) database entry
   -v -v -v -v              Show pubkey and certificate data, too

Lists certificates present in the database for 
the specified realm. If --all is not specified, only certificates
that have an alias defined for them are listed. --all lists all
certificates, regardless of whether they have an alias or not.
If --realm is left out, the certificates in all realms are listed
The number of -v's increases the verbosity (see above for what is
listed in which case).

=item B<import>

Subcommand options:

Mandatory:
  --realm                   PKI realm to import certificate to
  --file                    the PEM file to import from
  --issuer                  the issuer alias or identifier

Optional:
  --issuer-realm            the realm where the issuer alias
                            is defined
  --role                    the role of the certificate owner 

Force options (use only if you exactly now what you are doing!):
  --force-really-self-signed 
        The certificate is really self-signed
  --force-issuer-not-found
        Don't care that the issuer is not in the database
  --force-certificate-already-exists
        Don't care that the certificate is already in database

Once again, only use these options if you actually have to (the
occasions where this happens should be really, really rare).

Adds a certificate to the database. There are two different ways to
call it, depending on whether you have a self-signed certificate
or not. With a self-signed certificate, the --realm and --issuer options
are left out, with a "normal" certificate, they are mandatory.

The command outputs the subject's DN and the issuer's DN for you to
verify that you imported the correct certificate as well as a unique
identifier which can be used to globally reference the certificate
(i.e. for configuration or as an issuer). If you don't want to remember
the identifier, look into openxpkiadm certificate alias to find out
how to create a symbolic name for an identifier.

Examples: 

  openxpkiadm certificate import --file cacert.pem 

Imports a self-signed CA certificate.

  openxpkiadm certificate import --realm 'Root CA' \
        --file subca1.pem --issuer 'Root CA 1'

Imports a Sub CA certificate which is signed by Root CA 1.

=item B<remove>

Subcommand options:

Mandatory:
  --name            The alias or identifier of the certificate

Optional:
  --realm           The PKI realm in which the alias is defined

Force options (use only if you now what you are doing!):
  --force-is-issuer Delete certificate even though it is the
                    issuer of another certificate in the database

Removes a certificate from the database.

Example: 

  openxpkiadm certificate remove --realm 'Root CA' \
        --name 'Root CA 1'

=item B<chain>
 
Subcommand options:
 
 Mandatory:
  --realm               The PKI realm to operate in
  --name                The alias or identifier of the child
  --issuer              The alias or identifier of the parent
 
Optional:
  --issuer-realm        The realm in which the issuer alias
                        is defined

Force options (use only if you now what you are doing!):
  --force-certificate-not-found
        Ignore that the certificate of the child was not found
        in the DB
  --force-issuer-certificate-not-found
        Ignore that the certificate of the parent was not found
        in the DB
 
Once again, only use these options if you actually have to (the
occasions where this happens should be really, really rare).
 
Specifies subject/issuer relationship in order to set up certificate
chains. The certificates to be connected must already be present in
the database (see B<import>). As those connections are already set up
during --import, this command exists for changing the issuer if you
made an error. It also allows to specify an issuer that does not
agree with the information contained in the certificate (but outputs
a warning)
 
 Example: 
 
openxpkiadm certificate chain --realm 'Root CA' \
     --name 'Subordinate CA 1' --issuer 'root1'
 
=back 
 
=head2 alias

Using openxpkiadm certificate alias, you can create a symbolic name
for a certificate, which is associated with a specific PKI realm.
This symbolic name can then be used in some of the openxpkiadm commands
as well as in the configuration files.

Common options:
    --realm               PKI realm for the alias
    --identifier          The identifier of the certificate

Force options (use only if you now what you are doing!):
  --force-certificate-not-found
        Ignore that the certificate for which to create an
        alias was not found in the DB

Only use these options if you actually have to (the occasions where
this happens should be really, really rare).
    
There are different ways to deal with aliases:

=over 

=item B<add functional token with automatic group discovery>

Looks up the name of the associated group and finds the next generation
index by looking up the present aliases in the group. Recommended.    
    
  --token  The name of the token B<type> you want to add,
           e.g. I<certsign> or I<datasafe>.
          
Example: 

    openxpkiadm alias --realm server-realm \ 
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \ 
        --token certsign
      
=item B<add functional token with manual group configuration>

The alias for is automatically set to <group>-<generation>, e.g. server-ca-1.
  
  --group           The name of the group (e.g. server-ca)
  --generation      The numeric index to use for this alias

Example: 

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \ 
        --group server-ca --gen 1 

=item B<add non-functional alias>

Adds the alias leaving group and generation empty.
  
  --alias               The symbolic name for the certificate

Example: 

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \ 
        --alias my-very-important-certificate 
  
=item B<remove alias>

Remove the entry from the alias table.

  --remove          Indicates that the alias should be removed.
  --alias           You can select the alias by name rather than passing 
                    the identifier.  

Example: 

    openxpkiadm alias --remove --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \ 
    
    openxpkiadm alias --remove --realm server-realm \
        --alias server-ca-1 
 
=back 
 
=head2 loadcfg

Load the YaML config into the internal git repository.

Command options:

  --path DIR    Path to the YaML files 
  --dbpath DIR  Path to the internal repository 
  --reload      Signal the running server to immediately use the new config.
   
Read the files found at the config directory given by I<path> (defaults to
/etc/openxpki/config.d) and load them into the internal config repository at
the directory given by I<dbpath> (default /etc/openxpki/config.git).
If I<reload> is given and the openxpki daemon is running, the daemon is send
a reload signal and will start using the new configuration for new requests.   
Note: Even if I<reload> is not passed, the config becomes active on the next
server start!

=head1 DESCRIPTION

B<openxpkiadm> is the administrative frontend for controlling the OpenXPKI
installation.

=over 8

The openxpkiadm script returns a 0 exit value on success, and >0 if  an
error occurs.

=back

 





